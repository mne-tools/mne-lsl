
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "generated/tutorials/00_stream.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_generated_tutorials_00_stream.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_generated_tutorials_00_stream.py:


Introduction to the Stream API
==============================

.. include:: ./../../links.inc

An LSL stream can be consider as a continuous recording, with an unknown length and with
only access to the current and past samples. LSL streams can be separate in 2
categories:

* Streams with a **regular** sampling rate, which can be considered as a
  :class:`~mne.io.Raw` continuous recording.
* Streams with an **irregular** sampling rate, which can be considered as spontaneous
  events.

Both types can be managed through a ``Stream`` object, which represents a
single LSL stream with its buffer containing the current and past samples. The buffer
size is specified at instantiation through the ``bufsize`` argument.

.. GENERATED FROM PYTHON SOURCE LINES 22-47

Internal ringbuffer
-------------------

Once the :class:`~mne_lsl.stream.StreamLSL` object is connected to an LSL Stream, it
automatically updates an internal ringbuffer with newly available samples. A
ringbuffer, also called circular buffer, is a data structure that uses a single
fixed-size buffer as if it were connected and to end.

.. image:: ../../_static/tutorials/circular-buffer-light.png
    :align: center
    :class: only-light

.. image:: ../../_static/tutorials/circular-buffer-dark.png
    :align: center
    :class: only-dark

Typically, a ring buffer has 2 pointers:

* The "head" pointer, also called "start" or "read", which corresponds to the next
  data block to read.
* The "tail" pointer, also called "end" or "write", which corresponds to the next
  data block that will be overwritten with new data.

With a `~mne_lsl.stream.StreamLSL`, the pointers are hidden and the head pointer is
always updated to the last received sample.

.. GENERATED FROM PYTHON SOURCE LINES 49-63

Connect to a Stream
-------------------

Connecting to an LSL Stream is a 2 step operation. First, create a
:class:`~mne_lsl.stream.StreamLSL` with the desired buffer size and the desired stream
attributes, ``name``, ``stype``, ``source_id``. Second, connect to the stream which
matches the requested stream attributes with :meth:`mne_lsl.stream.StreamLSL.connect`.

.. note::

    For this tutorial purposes, a mock LSL stream is created using a
    :class:`~mne_lsl.player.PlayerLSL`. See
    :ref:`sphx_glr_generated_tutorials_10_player.py` for additional information on
    mock LSL streams.

.. GENERATED FROM PYTHON SOURCE LINES 63-79

.. code-block:: default


    import time

    from matplotlib import pyplot as plt

    from mne_lsl.datasets import sample
    from mne_lsl.lsl import local_clock
    from mne_lsl.player import PlayerLSL as Player
    from mne_lsl.stream import StreamLSL as Stream

    fname = sample.data_path() / "sample-ant-raw.fif"
    player = Player(fname)
    player.start()
    stream = Stream(bufsize=5)  # 5 seconds of buffer
    stream.connect(acquisition_delay=0.2)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Opening raw data file /home/runner/mne_data/MNE-LSL/sample/sample-ant-raw.fif...
    Isotrak not found
        Range : 0 ... 153602 =      0.000 ...   150.002 secs
    Ready.
    Reading 0 ... 153602  =      0.000 ...   150.002 secs...




.. GENERATED FROM PYTHON SOURCE LINES 80-86

Stream information
------------------

Similar to a :class:`~mne.io.Raw` recording and to most `MNE <mne stable_>`_ objects,
a :class:`~mne_lsl.stream.StreamLSL` has an ``.info`` attribute containing the channel
names, types and units.

.. GENERATED FROM PYTHON SOURCE LINES 86-89

.. code-block:: default


    stream.info






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table class="table table-hover table-striped table-sm table-responsive small">
        <tr>
            <th>Measurement date</th>
        
            <td>Unknown</td>
        
        </tr>
        <tr>
            <th>Experimenter</th>
        
            <td>Unknown</td>
        
        </tr>
            <th>Participant</th>
        
            <td>Unknown</td>
        
        </tr>
        <tr>
            <th>Digitized points</th>
        
            <td>Not available</td>
        
        </tr>
        <tr>
            <th>Good channels</th>
            <td>63 EEG, 2 EOG, 1 Galvanic skin response, 1 ECG, 1 Stimulus</td>
        </tr>
        <tr>
            <th>Bad channels</th>
            <td>None</td>
        </tr>
        <tr>
            <th>EOG channels</th>
            <td>vEOG, hEOG</td>
        </tr>
        <tr>
            <th>ECG channels</th>
            <td>ECG</td>
    
        <tr>
            <th>Sampling frequency</th>
            <td>1024.00 Hz</td>
        </tr>
    
    
        <tr>
            <th>Highpass</th>
            <td>0.00 Hz</td>
        </tr>
    
    
        <tr>
            <th>Lowpass</th>
            <td>512.00 Hz</td>
        </tr>
    
    
    </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 90-103

Depending on the LSL Stream source, the `~mne_lsl.stream.StreamLSL` may or may not be
able to correctly read the channel names, types and units.

* If the channel names are not readable or present, numbers will be used.
* If the channel types are not readable or present, the stream type or ``'misc'`` will
  be used.
* If the channel units are not readable or present, SI units will be used.

Once connected to a Stream, you can change the channel names, types and units to your
liking with :meth:`mne_lsl.stream.StreamLSL.rename_channels`,
:meth:`mne_lsl.stream.StreamLSL.set_channel_types` and
:meth:`mne_lsl.stream.StreamLSL.set_channel_units`. See
:ref:`sphx_glr_generated_tutorials_20_stream_meas_info.py` for additional information.

.. GENERATED FROM PYTHON SOURCE LINES 105-112

Channel selection
-----------------

Channels can be selected with :meth:`mne_lsl.stream.StreamLSL.pick` or with
:meth:`mne_lsl.stream.StreamLSL.drop_channels`. Selection is definitive, it is not
possible to restore channels removed until the :class:`~mne_lsl.stream.StreamLSL` is
disconnected and reconnected to its source.

.. GENERATED FROM PYTHON SOURCE LINES 112-116

.. code-block:: default


    stream.pick(["Fz", "Cz", "Oz"])
    stream.info






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table class="table table-hover table-striped table-sm table-responsive small">
        <tr>
            <th>Measurement date</th>
        
            <td>Unknown</td>
        
        </tr>
        <tr>
            <th>Experimenter</th>
        
            <td>Unknown</td>
        
        </tr>
            <th>Participant</th>
        
            <td>Unknown</td>
        
        </tr>
        <tr>
            <th>Digitized points</th>
        
            <td>Not available</td>
        
        </tr>
        <tr>
            <th>Good channels</th>
            <td>3 EEG</td>
        </tr>
        <tr>
            <th>Bad channels</th>
            <td>None</td>
        </tr>
        <tr>
            <th>EOG channels</th>
            <td>Not available</td>
        </tr>
        <tr>
            <th>ECG channels</th>
            <td>Not available</td>
    
        <tr>
            <th>Sampling frequency</th>
            <td>1024.00 Hz</td>
        </tr>
    
    
        <tr>
            <th>Highpass</th>
            <td>0.00 Hz</td>
        </tr>
    
    
        <tr>
            <th>Lowpass</th>
            <td>512.00 Hz</td>
        </tr>
    
    
    </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 117-132

Query the buffer
----------------

The ringbuffer can be queried for the last ``N`` samples with
:meth:`mne_lsl.stream.StreamLSL.get_data`. The argument ``winsize`` controls the
amount of samples returned, and the property
:py:attr:`mne_lsl.stream.StreamLSL.n_new_samples` contains the amount of new samples
buffered between 2 queries.

.. note::

    If the number of new samples between 2 queries is superior to the number of
    samples that can be hold in the buffer
    :py:attr:`mne_lsl.stream.StreamLSL.n_buffer`, the buffer is overwritten with some
    samples "lost" or discarded without any prior notice or error raised.

.. GENERATED FROM PYTHON SOURCE LINES 132-138

.. code-block:: default


    print(f"Number of new samples: {stream.n_new_samples}")
    data, ts = stream.get_data()
    time.sleep(0.5)
    print(f"Number of new samples: {stream.n_new_samples}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Number of new samples: 1648
    Number of new samples: 416




.. GENERATED FROM PYTHON SOURCE LINES 139-150

:meth:`mne_lsl.stream.StreamLSL.get_data` returns 2 variables, ``data`` which contains
the ``(n_channels, n_samples)`` data array and ``ts`` (or ``timestamps``) which
contains the ``(n_samples,)`` timestamp array, in LSL time.

.. note::

    LSL timestamps are not always regular. They can be jittered depending on the source
    and on the delay between the source and the client. Processing flags can be
    provided to improve the timestamp precision when connecting to a stream with
    :meth:`mne_lsl.stream.StreamLSL.connect`. See
    :ref:`sphx_glr_generated_tutorials_30_timestamps.py` for additional information.

.. GENERATED FROM PYTHON SOURCE LINES 150-166

.. code-block:: default


    t0 = local_clock()
    f, ax = plt.subplots(3, 1, sharex=True, constrained_layout=True)
    for _ in range(3):
        # figure how many new samples are available, in seconds
        winsize = stream.n_new_samples / stream.info["sfreq"]
        # retrieve and plot data
        data, ts = stream.get_data(winsize)
        for k, data_channel in enumerate(data):
            ax[k].plot(ts - t0, data_channel)
        time.sleep(0.5)
    for k, ch in enumerate(stream.ch_names):
        ax[k].set_title(f"EEG {ch}")
    ax[-1].set_xlabel("Timestamp (LSL time)")
    plt.show()




.. image-sg:: /generated/tutorials/images/sphx_glr_00_stream_001.png
   :alt: EEG Fz, EEG Cz, EEG Oz
   :srcset: /generated/tutorials/images/sphx_glr_00_stream_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 167-181

In the previous figure, the timestamps are corrected by ``t0``, which correspond to
the time at which the first loop was executed. Note that the samples in blue span
negative time values. Indeed, a 0.5 second sleep was added in the previous code cell
after the last :meth:`mne_lsl.stream.StreamLSL.get_data` call. Thus, ``t0`` is created
0.5 seconds after the last reset of :py:attr:`mne_lsl.stream.StreamLSL.n_new_samples`
and the samples pulled with the first :meth:`mne_lsl.stream.StreamLSL.get_data`
correspond to past samples.

Note also the varying number of samples in each of the 3 data query separated by
0.5 seconds. When connecting to a Stream with
:meth:`mne_lsl.stream.StreamLSL.connect`, an ``acquisition_delay`` is defined. It
corresponds to the delay between 2 updates of the ringbuffer, 200 ms in this example.
Thus, with a 500 ms sleep in this example, the number of samples updated in the
ringbuffer will vary every 2 iterations.

.. GENERATED FROM PYTHON SOURCE LINES 183-187

Apply processing to the buffer
------------------------------

TODO: add_reference_channels, set_eeg_reference, filter

.. GENERATED FROM PYTHON SOURCE LINES 189-193

Record a stream
---------------

TODO

.. GENERATED FROM PYTHON SOURCE LINES 195-200

Free resources
--------------
When you are done with a :class:`~mne_lsl.player.PlayerLSL` or
:class:`~mne_lsl.stream.StreamLSL`, don't forget to free the resources they both use
to continuously mock an LSL stream or receive new data from an LSL stream.

.. GENERATED FROM PYTHON SOURCE LINES 200-203

.. code-block:: default


    stream.disconnect()
    player.stop()








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 11.626 seconds)

**Estimated memory usage:**  120 MB


.. _sphx_glr_download_generated_tutorials_00_stream.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 00_stream.py <00_stream.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 00_stream.ipynb <00_stream.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
