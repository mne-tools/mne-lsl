
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "generated/examples/10_peak_detection.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_generated_examples_10_peak_detection.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_generated_examples_10_peak_detection.py:


Real-time peak detection
========================

With a :class:`~mne_lsl.stream.StreamLSL`, we can build a real-time peak detector. The
structure defined below will be adapted for cardiac R-peak detection, but remains
valid for other peak detector. Note however that the peak detection performance, i.e.
how fast it will be able to detect a peak, will depend heavily on the peak shape.

For this example, consider a :class:`~mne_lsl.stream.StreamLSL` connected to an
amplifier stream containing an ECG bipolar channel. We can detect in real-time the
R-peak within the ECG signal. The objective of this example is to create a ``Detector``
object able to detect new R-peak entering the buffer as fast as possible, with some
robustness to external noise sources (e.g. movements) and a simple design.

.. image:: ../../_static/tutorials/qrs.png
    :align: center
    :class: qrs-img

First let's have a look to a sample ECG signal and to how we could detect the R-peak
reliably with :func:`scipy.signal.find_peaks`.

.. GENERATED FROM PYTHON SOURCE LINES 23-36

.. code-block:: Python



    import numpy as np
    from matplotlib import pyplot as plt
    from mne.io import read_raw_fif
    from mne.viz import set_browser_backend
    from scipy.signal import find_peaks

    from mne_lsl.datasets import sample

    raw = read_raw_fif(sample.data_path() / "sample-ecg-raw.fif", preload=True)
    raw






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <script type="text/javascript">
        // must be `var` (not `const`) because this can get embedded multiple times on a page
    var toggleVisibility = (className) => {

        const elements = document.querySelectorAll(`.${className}`);

        elements.forEach(element => {
            if (element.classList.contains("mne-repr-section-header")) {
                return  // Don't collapse the section header row
            }
            element.classList.toggle("mne-repr-collapsed");
        });

        // trigger caret to rotate
        var sel = `.mne-repr-section-header.${className} > th.mne-repr-section-toggle > button`;
        const button = document.querySelector(sel);
        button.classList.toggle("collapsed");

        // adjust tooltip
        sel = `tr.mne-repr-section-header.${className}`;
        const secHeadRow = document.querySelector(sel);
        secHeadRow.classList.toggle("collapsed");
        secHeadRow.title = secHeadRow.title === "Hide section" ? "Show section" : "Hide section";
    }
    </script>

    <style type="text/css">
        /*
    Styles in this section apply both to the sphinx-built website docs and to notebooks
    rendered in an IDE or in Jupyter. In our web docs, styles here are complemented by
    doc/_static/styles.css and other CSS files (e.g. from the sphinx theme, sphinx-gallery,
    or bootstrap). In IDEs/Jupyter, those style files are unavailable, so only the rules in
    this file apply (plus whatever default styling the IDE applies).
    */
    .mne-repr-table {
        display: inline;  /* prevent using full container width */
    }
    .mne-repr-table tr.mne-repr-section-header > th {
        padding-top: 1rem;
        text-align: left;
        vertical-align: middle;
    }
    .mne-repr-section-toggle > button {
        all: unset;
        display: block;
        height: 1rem;
        width: 1rem;
    }
    .mne-repr-section-toggle > button > svg {
        height: 60%;
    }

    /* transition (rotation) effects on the collapser button */
    .mne-repr-section-toggle > button.collapsed > svg {
        transition: 0.1s ease-out;
        transform: rotate(-90deg);
    }
    .mne-repr-section-toggle > button:not(.collapsed) > svg {
        transition: 0.1s ease-out;
        transform: rotate(0deg);
    }

    /* hide collapsed table rows */
    .mne-repr-collapsed {
        display: none;
    }


    @layer {
        /*
        Selectors in a `@layer` will always be lower-precedence than selectors outside the
        layer. So even though e.g. `div.output_html` is present in the sphinx-rendered
        website docs, the styles here won't take effect there as long as some other rule
        somewhere in the page's CSS targets the same element.

        In IDEs or Jupyter notebooks, though, the CSS files from the sphinx theme,
        sphinx-gallery, and bootstrap are unavailable, so these styles will apply.

        Notes:

        - the selector `.accordion-body` is for MNE Reports
        - the selector `.output_html` is for VSCode's notebook interface
        - the selector `.jp-RenderedHTML` is for Jupyter notebook
        - variables starting with `--theme-` are VSCode-specific.
        - variables starting with `--jp-` are Jupyter styles, *some of which* are also
          available in VSCode. Here we try the `--theme-` variable first, then fall back to
          the `--jp-` ones.
        */
        .mne-repr-table {
            --mne-toggle-color: var(--theme-foreground, var(--jp-ui-font-color1));
            --mne-button-bg-color: var(--theme-button-background, var(--jp-info-color0, var(--jp-content-link-color)));
            --mne-button-fg-color: var(--theme-button-foreground, var(--jp-ui-inverse-font-color0, var(--jp-editor-background)));
            --mne-button-hover-bg-color: var(--theme-button-hover-background, var(--jp-info-color1));
            --mne-button-radius: var(--jp-border-radius, 0.25rem);
        }
        /* chevron position/alignment; in VSCode it looks ok without adjusting */
        .accordion-body .mne-repr-section-toggle > button,
        .jp-RenderedHTML .mne-repr-section-toggle > button {
            padding: 0 0 45% 25% !important;
        }
        /* chevron color; MNE Report doesn't have light/dark mode */
        div.output_html .mne-repr-section-toggle > button > svg > path,
        .jp-RenderedHTML .mne-repr-section-toggle > button > svg > path {
            fill: var(--mne-toggle-color);
        }
        .accordion-body .mne-ch-names-btn,
        div.output_html .mne-ch-names-btn,
        .jp-RenderedHTML .mne-ch-names-btn {
            -webkit-border-radius: var(--mne-button-radius);
            -moz-border-radius: var(--mne-button-radius);
            border-radius: var(--mne-button-radius);
            border: none;
            background-image: none;
            background-color: var(--mne-button-bg-color);
            color: var(--mne-button-fg-color);
            font-size: inherit;
            min-width: 1.5rem;
            padding: 0.25rem;
            text-align: center;
            text-decoration: none;
        }
        .accordion-body .mne-ch-names-btn:hover,
        div.output_html .mne.ch-names-btn:hover,
        .jp-RenderedHTML .mne-ch-names-btn:hover {
            background-color: var(--mne-button-hover-bg-color);
            text-decoration: underline;
        }
        .accordion-body .mne-ch-names-btn:focus-visible,
        div.output_html .mne-ch-names-btn:focus-visible,
        .jp-RenderedHTML .mne-ch-names-btn:focus-visible {
            outline: 0.1875rem solid var(--mne-button-bg-color) !important;
            outline-offset: 0.1875rem !important;
        }
    }
    </style>



    <table class="table mne-repr-table">
    







    <tr class="mne-repr-section-header general-25dd3eb7-c216-4295-8492-e56dd9104a3d"
         title="Hide section" 
        onclick="toggleVisibility('general-25dd3eb7-c216-4295-8492-e56dd9104a3d')">
        <th class="mne-repr-section-toggle">
            <button >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"/></svg>
            </button>
        </th>
        <th colspan="2">
            <strong>General</strong>
        </th>
    </tr>


    <tr class="repr-element general-25dd3eb7-c216-4295-8492-e56dd9104a3d ">
        <td class="mne-repr-section-toggle"></td>
        <td>Filename(s)</td>
        <td>
        
            sample-ecg-raw.fif
        
        
        </td>
    </tr>

    <tr class="repr-element general-25dd3eb7-c216-4295-8492-e56dd9104a3d ">
        <td class="mne-repr-section-toggle"></td>
        <td>MNE object type</td>
        <td>Raw</td>
    </tr>
    <tr class="repr-element general-25dd3eb7-c216-4295-8492-e56dd9104a3d ">
        <td class="mne-repr-section-toggle"></td>
        <td>Measurement date</td>
    
        <td>Unknown</td>
    
    </tr>
    <tr class="repr-element general-25dd3eb7-c216-4295-8492-e56dd9104a3d ">
        <td class="mne-repr-section-toggle"></td>
        <td>Participant</td>
    
        <td>Unknown</td>
    
    </tr>
    <tr class="repr-element general-25dd3eb7-c216-4295-8492-e56dd9104a3d ">
        <td class="mne-repr-section-toggle"></td>
        <td>Experimenter</td>
    
        <td>Unknown</td>
    
    </tr>
    







    <tr class="mne-repr-section-header acquisition-46492c5b-94fd-422a-9423-c776011004f5"
         title="Hide section" 
        onclick="toggleVisibility('acquisition-46492c5b-94fd-422a-9423-c776011004f5')">
        <th class="mne-repr-section-toggle">
            <button >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"/></svg>
            </button>
        </th>
        <th colspan="2">
            <strong>Acquisition</strong>
        </th>
    </tr>


    <tr class="repr-element acquisition-46492c5b-94fd-422a-9423-c776011004f5 ">
        <td class="mne-repr-section-toggle"></td>
        <td>Duration</td>
        <td>00:02:25 (HH:MM:SS)</td>
    </tr>








    <tr class="repr-element acquisition-46492c5b-94fd-422a-9423-c776011004f5 ">
        <td class="mne-repr-section-toggle"></td>
        <td>Sampling frequency</td>
        <td>1024.00 Hz</td>
    </tr>


    <tr class="repr-element acquisition-46492c5b-94fd-422a-9423-c776011004f5 ">
        <td class="mne-repr-section-toggle"></td>
        <td>Time points</td>
        <td>148,477</td>
    </tr>


    







    <tr class="mne-repr-section-header channels-1481cabc-f74b-4135-a219-e81a97799756"
         title="Hide section" 
        onclick="toggleVisibility('channels-1481cabc-f74b-4135-a219-e81a97799756')">
        <th class="mne-repr-section-toggle">
            <button >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"/></svg>
            </button>
        </th>
        <th colspan="2">
            <strong>Channels</strong>
        </th>
    </tr>


    
    <tr class="repr-element channels-1481cabc-f74b-4135-a219-e81a97799756 ">
        <td class="mne-repr-section-toggle"></td>
        <td>misc</td>
        <td>
            <button class="mne-ch-names-btn sd-sphinx-override sd-btn sd-btn-info sd-text-wrap sd-shadow-sm" onclick="alert('Good misc:\n\nAUX8')" title="(Click to open in popup)&#13;&#13;AUX8">
                1
            </button>

        
        </td>
    </tr>


    <tr class="repr-element channels-1481cabc-f74b-4135-a219-e81a97799756 ">
        <td class="mne-repr-section-toggle"></td>
        <td>Head & sensor digitization</td>
    
        <td>Not available</td>
    
    </tr>
    







    <tr class="mne-repr-section-header filters-61885473-1ca1-411f-b793-a094aff0e6a0"
         title="Hide section" 
        onclick="toggleVisibility('filters-61885473-1ca1-411f-b793-a094aff0e6a0')">
        <th class="mne-repr-section-toggle">
            <button >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"/></svg>
            </button>
        </th>
        <th colspan="2">
            <strong>Filters</strong>
        </th>
    </tr>


    <tr class="repr-element filters-61885473-1ca1-411f-b793-a094aff0e6a0 ">
        <td class="mne-repr-section-toggle"></td>
        <td>Highpass</td>
        <td>0.00 Hz</td>
    </tr>


    <tr class="repr-element filters-61885473-1ca1-411f-b793-a094aff0e6a0 ">
        <td class="mne-repr-section-toggle"></td>
        <td>Lowpass</td>
        <td>512.00 Hz</td>
    </tr>


    </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 38-39

This sample recording contains a single channel with the ECG signal.

.. GENERATED FROM PYTHON SOURCE LINES 39-44

.. code-block:: Python


    set_browser_backend("matplotlib")
    raw.plot(scalings=dict(misc=1300), show_scrollbars=False)
    plt.show()




.. image-sg:: /generated/examples/images/sphx_glr_10_peak_detection_001.png
   :alt: 10 peak detection
   :srcset: /generated/examples/images/sphx_glr_10_peak_detection_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 45-56

Filters
-------

This recording is heavily affected by line noise (50 Hz in Europe). Our detector
should filter the signal to distinguish easily the QRS complex and the associated
R-peaks. Let's compare the raw signal with filtered signal using the following
settings:

- notch at 50 and 100 Hz
- bandpass filter between 0.1 and 15 Hz
- lowpass filter at 15 Hz

.. GENERATED FROM PYTHON SOURCE LINES 56-67

.. code-block:: Python


    raw_notched = raw.copy()
    _ = raw_notched.notch_filter(50, method="iir", phase="forward", picks="misc")
    _ = raw_notched.notch_filter(100, method="iir", phase="forward", picks="misc")

    raw_bandpassed = raw.copy()
    _ = raw_bandpassed.filter(0.1, 15, method="iir", phase="forward", picks="misc")

    raw_lowpassed = raw.copy()
    _ = raw_lowpassed.filter(None, 15, method="iir", phase="forward", picks="misc")








.. GENERATED FROM PYTHON SOURCE LINES 68-76

To compare those signals, it would be best if we could overlay them in a single plot.
Let's select a 5 seconds window and plot the detrended signals.

.. note::

    Contrary to the filter used by a :class:`~mne_lsl.stream.StreamLSL`, the forward
    filter in MNE don't use initial filter conditions. Thus, the beginning of the
    filter signal should not be used as the filter has not yet converged.

.. GENERATED FROM PYTHON SOURCE LINES 76-91

.. code-block:: Python


    start = int(120 * raw.info["sfreq"])
    stop = int(125 * raw.info["sfreq"])
    fig, ax = plt.subplots(1, 1, figsize=(10, 5), layout="constrained")
    for raw_, label in zip(
        (raw, raw_notched, raw_bandpassed, raw_lowpassed),
        ("raw", "notched", "bandpassed", "lowpassed"),
        strict=True,
    ):
        data, times = raw_[:, start:stop]  # select 5 seconds
        data -= data.mean()  # detrend
        ax.plot(times, data.squeeze(), label=label)
    ax.legend()
    plt.show()




.. image-sg:: /generated/examples/images/sphx_glr_10_peak_detection_002.png
   :alt: 10 peak detection
   :srcset: /generated/examples/images/sphx_glr_10_peak_detection_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 92-94

Our first issue arises, the filter is altering the phase of the signal and thus the
shape of the QRS complex, shifting the R-peak to the right.

.. GENERATED FROM PYTHON SOURCE LINES 94-109

.. code-block:: Python


    start = int(121.2 * raw.info["sfreq"])
    stop = int(121.6 * raw.info["sfreq"])
    fig, ax = plt.subplots(1, 1, figsize=(10, 5), layout="constrained")
    for raw_, label in zip(
        (raw, raw_notched, raw_bandpassed, raw_lowpassed),
        ("raw", "notched", "bandpassed", "lowpassed"),
        strict=True,
    ):
        data, times = raw_[:, start:stop]  # select 5 seconds
        data -= data.mean()  # detrend
        ax.plot(times, data.squeeze(), label=label)
    ax.legend()
    plt.show()




.. image-sg:: /generated/examples/images/sphx_glr_10_peak_detection_003.png
   :alt: 10 peak detection
   :srcset: /generated/examples/images/sphx_glr_10_peak_detection_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 110-126

The lowpassed and bandpassed signals are heavily shifted, while the notched signal
retains the correct timing of the R-peak. Since our objective is to detect the R-peak
as soon as possible, it would be best to use the notched signal which has the highest
fidelity with the raw signal shape, while removing a large part of the background
noise.

Peak detection
--------------

Next, let's detect the R-peaks on the same 5 seconds window of the notched signal with
:func:`scipy.signal.find_peaks`.

.. note::

    We do not need to detrend to find peaks. Detrending was only useful to overlay the
    bandpassed signal with the raw, notched and lowpassed signals.

.. GENERATED FROM PYTHON SOURCE LINES 126-137

.. code-block:: Python


    start = int(120 * raw.info["sfreq"])
    stop = int(125 * raw.info["sfreq"])
    data, times = raw_notched[:, start:stop]
    peaks = find_peaks(data.squeeze())[0]
    fig, ax = plt.subplots(1, 1, layout="constrained")
    ax.plot(times, data.squeeze())
    for peak in peaks:
        ax.axvline(times[peak], color="red", linestyle="--")
    plt.show()




.. image-sg:: /generated/examples/images/sphx_glr_10_peak_detection_004.png
   :alt: 10 peak detection
   :srcset: /generated/examples/images/sphx_glr_10_peak_detection_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 138-143

The detected peaks are represented by the red dashed lines, and for now, the detection
is horrible. But we can improve it by setting the following constraints:

- height of the peak should be at least 98% of the data range
- distance between two peaks should be at least 0.5 seconds

.. GENERATED FROM PYTHON SOURCE LINES 143-158

.. code-block:: Python


    start = int(120 * raw.info["sfreq"])
    stop = int(125 * raw.info["sfreq"])
    data, times = raw_notched[:, start:stop]
    peaks = find_peaks(
        data.squeeze(),
        height=np.percentile(data.squeeze(), 98),
        distance=0.5 * raw_notched.info["sfreq"],
    )[0]
    fig, ax = plt.subplots(1, 1, layout="constrained")
    ax.plot(times, data.squeeze())
    for peak in peaks:
        ax.axvline(times[peak], color="red", linestyle="--")
    plt.show()




.. image-sg:: /generated/examples/images/sphx_glr_10_peak_detection_005.png
   :alt: 10 peak detection
   :srcset: /generated/examples/images/sphx_glr_10_peak_detection_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 159-166

Adjusting the peak detection constraints to your signal is crucial.

Detector
--------

Now that we have a good idea of how to detect the R-peaks, let's create a real-time
``Detector`` object that will detect the R-peaks as soon as they enter the buffer.

.. GENERATED FROM PYTHON SOURCE LINES 166-237

.. code-block:: Python


    from time import sleep

    import numpy as np
    from numpy.typing import NDArray
    from scipy.signal import find_peaks

    from mne_lsl.stream import StreamLSL

    ECG_HEIGHT: float = 98.0  # percentile height constraint, in %
    ECG_DISTANCE: float = 0.5  # distance constraint, in seconds


    class Detector:
        """Real-time single channel peak detector.

        Parameters
        ----------
        bufsize : float
            Size of the buffer in seconds. The buffer will be filled on instantiation, thus
            the program will hold during this duration.
        stream_name : str
            Name of the LSL stream to use for the respiration or cardiac detection. The
            stream should contain a respiration channel using a respiration belt or a
            thermistor and/or an ECG channel.
        stream_source_id : str | None
            A unique identifier of the device or source of the data. If not empty, this
            information improves the system robustness since it allows recipients to recover
            from failure by finding a stream with the same source_id on the network.
        ch_name : str
            Name of the ECG channel in the LSL stream. This channel should contain the ECG
            signal recorded with 2 bipolar electrodes.

        """

        def __init__(
            self,
            bufsize: float,
            stream_name: str,
            stream_source_id: str | None,
            ch_name: str,
        ) -> None:
            # create stream
            self._stream = StreamLSL(
                bufsize, name=stream_name, source_id=stream_source_id
            ).connect(acquisition_delay=None, processing_flags="all")
            self._stream.pick(ch_name)
            self._stream.set_channel_types({ch_name: "misc"}, on_unit_change="ignore")
            self._stream.notch_filter(50, picks=ch_name)
            self._stream.notch_filter(100, picks=ch_name)
            sleep(bufsize)  # prefill an entire buffer

        def detect_peaks(self) -> NDArray[np.float64]:
            """Detect all peaks in the buffer.

            Returns
            -------
            peaks : array of shape (n_peaks,)
                The timestamps of all detected peaks.
            """
            self._stream.acquire()
            data, ts = self._stream.get_data()  # we have a single channel in the stream
            data = data.squeeze()
            peaks, _ = find_peaks(
                data,
                distance=ECG_DISTANCE * self._stream.info["sfreq"],
                height=np.percentile(data, ECG_HEIGHT),
            )
            return ts[peaks]









.. GENERATED FROM PYTHON SOURCE LINES 238-254

The object above is a good start, but it will detect all peaks in the buffer and it
doesn't have any memory of which peak was already detected. We need to add some
triage logic on the detected peaks and a memory of the last detected peak(s).

The triage logic will:

- detect all peaks in the current buffer
- create a list of peak candidates which correspond to detected peaks which have not
  yet been selected as 'latest peak'
- count the number of times each peak candidate is detected
- if a peak candidate is detected 4 times, the most recent peak candidate becomes the
  latest peak and is returned (i.e. detected)

The triage logic uses a memory of the last detected peaks to count the number of peak
candidates between 2 iteration, and to store the last known detected peak. This is
simplify achieved by storing the LSL time at which the peak was detected.

.. GENERATED FROM PYTHON SOURCE LINES 254-385

.. code-block:: Python


    from time import sleep

    import numpy as np
    from numpy.typing import NDArray
    from scipy.signal import find_peaks

    from mne_lsl.stream import StreamLSL

    ECG_HEIGHT: float = 98.0  # percentile height constraint, in %
    ECG_DISTANCE: float = 0.5  # distance constraint, in seconds


    class Detector:
        """Real-time single channel peak detector.

        Parameters
        ----------
        bufsize : float
            Size of the buffer in seconds. The buffer will be filled on instantiation, thus
            the program will hold during this duration.
        stream_name : str
            Name of the LSL stream to use for the respiration or cardiac detection. The
            stream should contain a respiration channel using a respiration belt or a
            thermistor and/or an ECG channel.
        stream_source_id : str | None
            A unique identifier of the device or source of the data. If not empty, this
            information improves the system robustness since it allows recipients to recover
            from failure by finding a stream with the same source_id on the network.
        ch_name : str
            Name of the ECG channel in the LSL stream. This channel should contain the ECG
            signal recorded with 2 bipolar electrodes.
        """

        def __init__(
            self,
            bufsize: float,
            stream_name: str,
            stream_source_id: str | None,
            ch_name: str,
        ) -> None:
            # create stream
            self._stream = StreamLSL(
                bufsize, name=stream_name, source_id=stream_source_id
            ).connect(acquisition_delay=None, processing_flags="all")
            self._stream.pick(ch_name)
            self._stream.set_channel_types({ch_name: "misc"}, on_unit_change="ignore")
            self._stream.notch_filter(50, picks=ch_name)
            self._stream.notch_filter(100, picks=ch_name)
            sleep(bufsize)  # prefill an entire buffer
            # peak detection settings
            self._last_peak = None
            self._peak_candidates = None
            self._peak_candidates_count = None

        def detect_peaks(self) -> NDArray[np.float64]:
            """Detect all peaks in the buffer.

            Returns
            -------
            peaks : array of shape (n_peaks,)
                The timestamps of all detected peaks.
            """
            self._stream.acquire()
            if self._stream.n_new_samples == 0:
                return np.array([])  # nothing new to do
            data, ts = self._stream.get_data()  # we have a single channel in the stream
            data = data.squeeze()
            peaks, _ = find_peaks(
                data,
                distance=ECG_DISTANCE * self._stream.info["sfreq"],
                height=np.percentile(data, ECG_HEIGHT),
            )
            return ts[peaks]

        def new_peak(self) -> float | None:
            """Detect new peak entering the buffer.

            Returns
            -------
            peak : float | None
                The timestamp of the newly detected peak. None if no new peak is detected.
            """
            ts_peaks = self.detect_peaks()
            if ts_peaks.size == 0:
                return None
            if self._peak_candidates is None and self._peak_candidates_count is None:
                self._peak_candidates = list(ts_peaks)
                self._peak_candidates_count = [1] * ts_peaks.size
                return None
            peaks2append = []
            for k, peak in enumerate(self._peak_candidates):
                if peak in ts_peaks:
                    self._peak_candidates_count[k] += 1
                else:
                    peaks2append.append(peak)
            # before going further, let's make sure we don't add too many false positives,
            # which could be indicative of noise in the signal (e.g. movements)
            if int(self._stream._bufsize * (1 / ECG_DISTANCE)) < len(peaks2append) + len(
                self._peak_candidates
            ):
                self._peak_candidates = None
                self._peak_candidates_count = None
                return None
            self._peak_candidates.extend(peaks2append)
            self._peak_candidates_count.extend([1] * len(peaks2append))
            # now, all the detected peaks have been triage, let's see if we have a winner
            idx = [k for k, count in enumerate(self._peak_candidates_count) if 4 <= count]
            if len(idx) == 0:
                return None
            peaks = sorted([self._peak_candidates[k] for k in idx])
            # compare the winner with the last known peak
            if self._last_peak is None:  # don't return the first peak detected
                new_peak = None
                self._last_peak = peaks[-1]
            if self._last_peak is None or self._last_peak + ECG_DISTANCE <= peaks[-1]:
                new_peak = peaks[-1]
                self._last_peak = peaks[-1]
            else:
                new_peak = None
            # reset the peak candidates
            self._peak_candidates = None
            self._peak_candidates_count = None
            return new_peak

        @property
        def stream(self):
            """Stream object."""
            return self._stream









.. GENERATED FROM PYTHON SOURCE LINES 386-393

Performance
-----------

Let's now test this detector and measure the time it takes to detect a new peak
entering the buffer. To properly do so, the player should be started in a separate
process to avoid hogging the CPU time in the main thread leaving no time for the
player to stream new data.

.. GENERATED FROM PYTHON SOURCE LINES 393-420

.. code-block:: Python


    import multiprocessing as mp
    import uuid


    def player_process(fname, name, source_id, status):
        """Process which runs the process."""
        from mne_lsl.player import PlayerLSL

        player = PlayerLSL(fname, chunk_size=1, name=name, source_id=source_id)
        player.start()
        status.value = 1
        while status.value:
            pass
        player.stop()


    fname = sample.data_path() / "sample-ecg-raw.fif"
    name = "ecg-example"
    source_id = uuid.uuid4().hex
    manager = mp.Manager()
    status = manager.Value("i", 0)
    process = mp.Process(target=player_process, args=(fname, name, source_id, status))
    process.start()
    while status.value != 1:
        pass  # wait for the player to actually start








.. GENERATED FROM PYTHON SOURCE LINES 421-423

Now that a :class:`~mne_lsl.player.PlayerLSL` is running in a separate process, we can
start the detector and measure the time it takes to detect a new peak.

.. GENERATED FROM PYTHON SOURCE LINES 423-440

.. code-block:: Python


    from mne_lsl.lsl import local_clock

    detector = Detector(4, name, source_id, "AUX8")
    delays = list()
    while len(delays) <= 30:
        peak = detector.new_peak()
        if peak is not None:
            delays.append((local_clock() - peak) * 1e3)
    detector.stream.disconnect()
    status.value = 0  # stops the player

    f, ax = plt.subplots(1, 1, layout="constrained")
    ax.set_title("Detection delay in ms")
    ax.hist(delays, bins=15)
    plt.show()




.. image-sg:: /generated/examples/images/sphx_glr_10_peak_detection_006.png
   :alt: Detection delay in ms
   :srcset: /generated/examples/images/sphx_glr_10_peak_detection_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 441-445

The detection delay displayed can be as low as 1 or 2 ms depending on the computer, on
the process configuration and on the performance of the streaming source. A
:class:`~mne_lsl.player.PlayerLSL` is not reproducing exactly the performance of a
real-time application.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 37.429 seconds)

**Estimated memory usage:**  190 MB


.. _sphx_glr_download_generated_examples_10_peak_detection.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 10_peak_detection.ipynb <10_peak_detection.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 10_peak_detection.py <10_peak_detection.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: 10_peak_detection.zip <10_peak_detection.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
